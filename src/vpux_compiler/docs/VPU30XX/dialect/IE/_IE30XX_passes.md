<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `-convert-tile-to-per-axis-tiles`: Convert tile op by multiple axes to multiple PerAxisTile operations
The pass is a part of `AdjustForVPU` pipeline.

This pass replaces all `Tile` op with a set of `PerAxisTile` operations.
### `-expand-activation-channels`: Align input tensors shape of DPU operation with hardware requirements
The pass is a part of `buildHardwareModePipeline` pipeline.

This pass processes operations, which can be compile as a DPU tasks and
    expands channels number to number divisible by 16 in case they doesn't satisfy hardware requirements

#### Options
```
-se-ops-enabled : Flag to identify whether operations that can be executed using the Storage Element hardware feature are enabled
```
### `-insert-identity-pool-before-op`: Insert Maxpool/AvgPool op before Activation ops and MemPermute ops
The pass inserts MaxPool/AvgPool op before Activation ops and MemPermute ops.
MaxPool/AvgPool will be lowered to a NCE op and the activation op will be fused into it.
Supported activations: LeakyRelu, Clamp.
### `-map-bilinear-interpolate-on-dpu`: Convert bilinear interpolate op to strided concat, MaxPool and some depthwise convolution Ops
Purpose:
This pass replaces `Bilinear Interpolate` for which tiling is required to fit in CMX
with sequences of operation that can be mapped on DPU and DMA.

How it works:
The supported interpolation axis currently supported are H and W.
For each of these axis the scaling is happening individually, first perform vertical scaling and after perform horizontal scaling.
On each axis the processing is split in three main regions BEGIN, MIDDLE and END.
These three regions refers to slices from the output tensor and are influenced by the coordinate transformation mode attribute.
* BEGIN - refers to the slice from output for which it is only needed to duplicate the first line/column from input
* MIDDLE - refers to the slice from output where:
            * for each output line/column from the output it is required to take two consecutive lines/colums from the input
            * based on the coordinate transformation mode attribute compute the weight coefficients each of two lines/columns
              has on theresulting output line/column
            * each output line/column is computed with a GroupConvolution operation for which the weights are obtained by expanding
             the weight coefficients of the input lines/columns
* END - refers to the slice from output for which it is only needed to duplicate the last line/column from input
```
Vertical scaling:                    Horizontal scaling
________________________       ____________________________
|        BEGIN         |       |   |                  |   |
|______________________|       |   |                  |   |
|                      |       | B |        M         |   |
|                      |       | E |        I         | E |
|        MIDDLE        |       | G |        D         | N |
|                      |       | I |        D         | D |
|______________________|       | N |        L         |   |
|         END          |       |   |        E         |   |
|______________________|       |___|__________________|___|
```

The rewrite implemented per each region is described below:
 BEGIN region:
```         Input
              |
            Slice
       first line/column
        |    ...    |
    Identity       Identity
    MaxPool        MaxPool

 MIDDLE region
                 Input
          ---------|---------
         |                   |
     Slice        ...       Slice
 two lines/colums       two lines/colums
       |                        |
   GroupConv               GroupConv
 one output line/colum   one output line/colum

 END region:
            Input
              |
            Slice
       last line/column
        |    ...     |
    Identity       Identity
    MaxPool        MaxPool
```
At the end the results of all the operation resulted are concatenated together on the scaling axis.

In case the `interpolateAsSEOp` option is set to true, only cases that cannot be executed
using the Storage Element hardware feature will be converted to concats.

#### Options
```
-interpolate-as-se-op : Flag which identifies whether an Interpolate operation can be executed using the Storage Element hardware feature
```
### `-optimize-slice-expand`: Optimize patterns Slice->Expand and Slice->Implicit operations ->Expand
The pass is a part of `buildHardwareModePipeline` pipeline.

Optimize patterns Slice->Expand and Slice->Implicit operations ->Expand in order to avoid extra DMAs
### `-unroll-batch`: Split inputs of NCE tasks when their batch size is greater than 1
This pass splits inputs of NCE tasks by batch.

For example:
* `FullyConnected` input with 2x64 geometry will be split by two inputs with 1x64 dimensions.
* `Convolution` input 3x16x32x64 will be split into three 1x16x32x64 inputs.
Resulting tensors go to corresponding operations and the outputs are concatenated.
